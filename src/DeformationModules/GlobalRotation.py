# -*- coding: utf-8 -*-
"""
Created on Thu Apr 18 10:06:35 2019

@author: gris
"""

import numpy as np

import src.DeformationModules.Abstract as ab
import src.GeometricalDescriptors.Landmark as GeoDescr
from src.StructuredFields.LinearField import LinearField
from src.StructuredFields.ConstantField import ConstantField

rot_mat = np.array([[0., -1.], [1., 0.]])

class GlobalRotation(ab.DeformationModule):
    """
     GlobalRotation
    """
    
    def __init__(self, dim, coeff):
        """
        dim is the dimension of the ambient space
        """
        self.dim = dim
        self.coeff = coeff
        self.GD = GeoDescr.GD_landmark(1, dim)
        self.Cont = np.zeros([1])
        self.cost = 0.
    
    def copy(self):
        return GlobalRotation(self.dim, self.coeff)
    
    def copy_full(self):
        Mod = GlobalRotation(self.dim, self.coeff)
        Mod.GD = self.GD.copy_full()
        Mod.Cont = self.Cont.copy()
        Mod.cost = self.cost
        return Mod
    
    def fill_GD(self, GD):
        self.GD = GD.copy_full()
    
    def fill_Cont(self, Cont):
        self.Cont = Cont.copy()
    
    
    def update(self):
        """
        Supposes that values of GD have been filled
        """
        pass
    
    def GeodesicControls_curr(self, GDCot):
        """
        Supposes that GDCot has Cot filled
        """
        
        Cont_geo = np.zeros([1])
        v = LinearField(self.dim, rot_mat)
        param = [self.GD.GD, np.ones([1])]
        v.fill_fieldparam(param)
        Cont_geo[0] = (1. / self.coeff) * GDCot.inner_prod_v(v)
        self.Cont = Cont_geo.copy()
    
    def field_generator_curr(self):
        return self.field_generator(self.GD, self.Cont)
    
    def field_generator(self, GD, Cont):
        param =  [self.GD.GD, Cont]
        v = LinearField(self.dim, rot_mat)
        v.fill_fieldparam(param)
        return v
    
    def Cost_curr(self):
        p = self.Cont.flatten()
        self.cost = self.coeff * np.dot(p,  p) / 2
    
    def Cost(self, GD, Cont):
        p = Cont.flatten()
        return self.coeff * np.dot(p, p) / 2
    
    def DerCost_curr(self):
        out = self.GD.copy()
        out.fill_zero_tan()
        return out
    

    def cot_to_innerprod_curr(self, GDCot, j):  #
        """
         Transforms the GD (with Cot filled) GDCot into vsr and computes
         the inner product (or derivative wrt self.GD) with the
         field generated by self.
         The derivative is a returned as a GD with cotan filled (tan=0)
         
         Here: if j=0, computes field and applies it to GDCot,
                if j=1 derivation is 0.
        """        
        
        if j == 0:
            v = self.field_generator_curr()
            out = GDCot.inner_prod_v(v)
        if j == 1:
            # The derivative with respect to self.GD is a constant field
            out = self.GD.copy()
            cotan = np.zeros([1, self.dim])
            for i in range(self.dim):
                v = ConstantField(self.dim)
                v.mom = - self.Cont[0] * rot_mat[:, i].reshape([1,-1])
                cotan[0, i] = GDCot.inner_prod_v(v)
                
            out.GD = self.GD.GD.copy()
            out.cotan = cotan.copy()

        return out
