=======
Registration framework
=======

Deformation modules
=======


Mathematical definition
-------------------
A deformation module is a structure :math:`(\mathcal O, H, \zeta, \xi, c)` where :math:`\mathcal O` is the space of **geometrical descriptors**, :math:`H` is the space of **controls**, :math:`\zeta : \mathcal O \times H \mapsto C^\ell_0 (\mathbb R^d, \mathbb R^d)` is the **field generator**, :math:`\xi : (q,v) \in  \mathcal O \times C^\ell (\mathbb R^d, \mathbb R^d) \mapsto \xi_q (v) = v \cdot q \in T \mathcal O` is the **infinitesimal action** and :math:`c : \mathcal O \times H \mapsto \mathbb R^+` is the **cost**.

The field generator specifies the vector fields that can be generated by the deformation module, *i.e.* the structure that is incorporated in the deformation model. 

It is possible to combine several deformation modules :math:`M^i = (\mathcal O^i, H^i, \zeta^i, \xi^i, c^i)`, :math:`1 \leq i \leq N`, to build the compound module :math:`(\mathcal O, H, \zeta, \xi, c)` defined by :math:`\mathcal O = \prod_{i=1}^N \mathcal O^i`, :math:`H = \prod_{i=1}^N H^i`, :math:`\zeta: ( q,h) \in \mathcal O \times H \mapsto \sum_i \zeta^i_{q^i} h^i`, :math:`\xi : (q,v) \in  \mathcal O \times C^\ell (\mathbb R^d, \mathbb R^d) \mapsto (\xi_q^1 (v), \dots, \xi_q^1 (v) )`and :math:`c:  ( q,h) \in \mathcal O \times H \mapsto \sum_i c^i_{q^i} h^i` with :math:`q= (q_1, \dots, q_N)`, :math:`h=(h_1, \dots, h_N)`.



Implementation
-------------------
A **deformation module** is defined as a class whose main method is a **field generator** which specifies, for each module, the vector fields that can be generated. It uses the **manifold** and the **control** of the deformation modules and returns a **structured vector field**. The manifold is itself a class implementing the notion of geometrical descriptor and, more generally, of all *geometrical objects* which can be displaced through the action of a vector field. This action is defined by the **infinitesimal action** method. The control variable is a tensor. Structured vector fields implement the mathematical notion of vector field: they can be applied to a tensor of points and return a tensor of speeds. The second key method for a deformation module is the **cost** which associates a scalar cost to a couple of a manifold and a control.

The combination of deformation module is implemented via the class **CompoundModule** which is built from a list of deformation modules.




Modular large deformations
=======

Mathematical definition
-------------------

A modular large deformation is a *diffeomorphism* built as a flow of *modular vector fields*, *i.e.* a trajectory of vector fields generated by a given deformation module :math:`(\mathcal O, H, \zeta, \xi, c)`. It is then parametrized by a trajectory :math:`t \in [0, 1] \mapsto (q_t, h_t) \in \mathcal O \times H` of geometrical descriptor and control. Under some conditions, the corresponding trajectory of field :math:`t \in [0,1] \mapsto v_t \doteq \zeta_{q_t} (h_t)` can be integrated: the flow :math:`\varphi^{\zeta_q (h)}` defined by :math:`\varphi_{t=0}^{\zeta_q(h)}` and :math:`\dot{\varphi}_t^{\zeta_q(h)} = \zeta_q(h) \circ \varphi^{\zeta_q(h)}` exists.

We are interested in particular trajectories: the *geodesic* ones. They are parametrized by an initial value of geometrical descriptor :math:`q_0 \in \mathcal O` and *momentum* :math:`p_0 \in T_{q_0} ^\ast \mathcal O` and satisfy the following *shooting equation*

:math:`\dot{q}_t =  \frac{\partial H}{\partial p} (q_t, p_t, h_t) = \xi_{q_t} \circ \zeta_{q_t} (h_t)`

:math:`\dot{p}_t  =   -\frac{\partial H}{\partial q} (q_t, p_t, h_t)`

:math:`h_t = Z_{q_t}^{-1} (\xi_{q_t} \circ \zeta_{q_t}) ^\ast p_t`

where :math:`H : (q, p, h) \in T^\ast \mathcal O \times H \mapsto (p | \xi_{q_t} \circ  \zeta_q (h)) - \frac{1}{2} c_q(h)` is the *Hamiltonian* and :math:`Z_q : H \mapsto H^\ast` is such that :math:`(Z_q (h), h) = c_q (h)` for all :math:`(q,h) \in \mathcal O \times H`.

Implementation
-------------------
The **shoot** class implements the shooting equations. It takes as input an **Hamiltonian** implementing the mathematical Hamiltonian which is itself defined from a deformation module. The manifold of the deformation module contains an attribute **gd** implementing the geometrical descriptor :math:`q` and an attribute **cotan** implementing the momentum :math:`p` which are used as initial conditions for the shooting equation. The geodesic control :math:`h_t = Z_{q_t}^{-1} (\xi_{q_t} \circ \zeta_{q_t}) ^\ast p_t` is computed at each time using the method **compute_geodesic_control** of the deformation module. 

The **shoot** class can also take in input a list of controls (implementing a trajectory of controls) which are used at each time instead of the geodesic ones. This can be used for instance to study the influence of one specific component of the controls.





Modular registration
=======

Mathematical definition
-------------------

Given a couple of source and target shapes :math:`(f_S, f_T)` in a shape space :math:`S` and a deformation module :math:`M = (\mathcal O, H, \zeta, \xi, c)`, the goal is to estimate the *best* (geodesic) modular large deformation generated by :math:`M` transporting :math:`f_S` as close as possible to :math:`f_T`. This amounts to minimizing the registration functional :math:`J(q_0, p_0, p^S_0) \in T^\ast \mathcal O \times T^\ast_{f_S} \mathcal F \mapsto \int_0^1 c_{q_t} (h_t) d t + D (\varphi^{\zeta_q (h)}_{t=1} \cdot f_S , f_T)` with :math:`((q, q^S), (p p^S))` satisfying the shooting equation for the combination of $M$ and the silent deformation module induced by :math:`S`.



Implementation
-------------------

The class **RegistrationModel** is the keystone allowing to perform a registration using a chosen deformation model. It is initialized with lists of **Deformable**, **Attachment** (defining the attachment functions for these data) and **DeformationModules**. A **Deformable** is a class implementing the notion of geometric data: it gathers point clouds, meshes and images. To each element of the Deformable list, is associated an **Attachment** implementing a distance between to Deformables of the same class. Several Attachments are implemented such euclidean distance for point clouds, the varifold distance for curves or meshes and  :math:`L^2` distance for images. The class **RegistrationModel** allows to compute the shooting equation, the initial value of geometrical descriptor and momentum being stored in the attribute **init_manifold**. It also enables to compute the registration function with the **evaluate** method which takes as input a list of **Deformable** targets.
In order to minimize this functional, a **Fitter** class is created from **RegistrationModel** and runs the optimisation. It interfaces most PyTorch and Scipy optimizers along with a gradient descent with linear search optimization algorithm.
It is possible to estimate the parameters of the deformation modules with a key-word **other_parameters** in **RegistrationModel**. It is also possible to add a callback function that is evaluated before model evaluation. This allows us to estimate some parameters of the model as functions of meta-parameters which can be estimated. 


===============================
Implemented deformation modules
===============================

Explicit deformation modules
===============================

Some deformation modules are said to be *explicit* in the sense that their field generator is explicitly given in the definition. 


Local translations
------------------

Mathematical definition
^^^^^^^^^^^^^^^^^^^^^^^


This module generates a sum of local translations, localized by a chosen kernel :math:`K`. We only consider for the moment scalar Gaussian kernel :math:`K_\sigma` with :math:`\sigma >0`.

Let :math:`P` be an fixed integer, the deformation modules generating a sum of :math:`P` translations is defined by:


*  :math:`\mathcal O = (\mathbb R^d)^P`

*  :math:`H = (\mathbb R^d)^P`

*  :math:`\zeta: (q,h)  \in \mathcal O \times H \mapsto  \sum_{i=1}^P K(x_i, \cdot) h_i  \in C^\ell (\mathbb R^d, \mathbb R^d)` where :math:`q = (x_1, \dots, x_P)` and :math:`h = (h_1, \dots, h_P)`

*  :math:`\xi: (q,v)  \in \mathcal O \times C^\ell (\mathbb R^d, \mathbb R^d) \mapsto  (v(x_1), \dots, v(x_P)) \in T_q \mathcal O` where :math:`q = (x_1, \dots, x_P)`

*  :math:`c: (q,h)  \in \mathcal O \times H \mapsto   |\zeta_q (h)|^2_{V_\sigma} \in \mathbb R^+`



Implementation
^^^^^^^^^^^^^^^^^^^^^^^

This module is implemented in the class **Translations** which is initialized by a scalar :math:`\sigma` (scale of the scalar Gaussian kernel), an integer :math:`d` (dimension of the ambient space) and and integer :math:`p` (number of local translations).



Constrained local translations
------------------------------

Mathematical definition
^^^^^^^^^^^^^^^^^^^^^^^

This deformation module builds also sum of local translations but imposes some links between them to constrain the generated field. Let :math:`N` be an integer and two functions :math:`f : (\mathbb R^d)^N \mapsto (\mathbb R^d)^P`,  :math:`g: (\mathbb R^d)^N \mapsto (\mathbb R^d)^P`, we define the corrsponding deformation module by


*  :math:`\mathcal O = (\mathbb R^d)^N`

*  :math:`H = \mathbb R`

*  :math:`\zeta: (q,h)  \in \mathcal O \times H \mapsto  h \sum_{i=1}^P K(f(q)_i, \cdot) g(x)_i  \in C^\ell (\mathbb R^d, \mathbb R^d)` where :math:`f(q) =  = (f(q)_1, \dots, f(q)_P)` and :math:`g(q) =  = (g(q)_1, \dots, g(q)_P)`

*  :math:`\xi: (q,v)  \in \mathcal O \times C^\ell (\mathbb R^d, \mathbb R^d) \mapsto  (v(x_1), \dots, v(x_P)) \in T_q \mathcal O` where :math:`q = (x_1, \dots, x_N)`

*  :math:`c: (q,h)  \in \mathcal O \times H \mapsto  |\zeta_q (h)|^2_{V_\sigma} \in \mathbb R^+`



Implementation
^^^^^^^^^^^^^^^^^^^^^^^

This module is implemented in the class **LocalConstrainedTranslations** which is initialized 


Silent
------

Mathematical definition
^^^^^^^^^^^^^^^^^^^^^^^

Implementation
^^^^^^^^^^^^^^^^^^^^^^^



Implicit deformation modules
===============================

Order 0
-------

Mathematical definition
^^^^^^^^^^^^^^^^^^^^^^^

Implementation
^^^^^^^^^^^^^^^^^^^^^^^


Order 1
-------

Mathematical definition
^^^^^^^^^^^^^^^^^^^^^^^

Implementation
^^^^^^^^^^^^^^^^^^^^^^^





.. toctree::
   :maxdepth: 2
   :caption: Modules

